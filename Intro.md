# 以下是对代码的详细注释：

## is_valid_state(missionaries, cannibals)
#### 这个函数用于检查给定状态是否有效。如果给定的状态导致了修道士被野人吃掉，则返回 False，否则返回 True。

## solve_river_crossing_problem()
#### 这个函数实现了使用深度优先搜索算法求解过河问题的解决方案。在该函数中，首先定义了初始状态为 (3, 3, 'left')，表示开始时所有人都在左岸。接着，定义了一个列表 solutions 用于保存所有的解决方案。定义了一个栈 stack 作为搜索状态的容器。 

#### 接下来进入 while 循环，在每次循环中，从栈中取出一个状态和路径，并将其赋值给变量 state 和 path。然后，将状态中的 missionaries，cannibals 和 boat 取出，分别赋值给变量 missionaries，cannibals 和 boat。

#### 如果在当前状态下，所有修道士和野人都已经安全到达右岸，则将当前路径 path 添加到解决方案 solutions 中，并跳过后续步骤，进入下一次循环。

#### 接着，根据当前船只所在的岸边，确定接下来可行的移动方向。如果船在左岸，可选的方向为从左岸到右岸，对应的移动方式是 (2, 0)（两个修道士过河），(0, 2)（两个野人过河），(1, 1)（一个修道士和一个野人过河），(1, 0)（一个修道士过河），(0, 1)（一个野人过河）。如果船在右岸，可选的方向为从右岸到左岸，对应的移动方式与左岸到右岸的移动方式相同，只是方向相反。

#### 接下来，对于每个可行的移动方向，根据当前状态和移动方式计算新的修道士数量、野人数量和船的位置，并将其组成一个新的状态 new_state。然后，检查新状态是否有效（即没有修道士被野人吃掉）并且该状态不在当前路径中，如果满足条件，则将新状态和更新后的路径加入到栈 stack 中，以便进一步搜索。

#### 最后，当栈为空时，结束循环，将解决方案列表 solutions 返回。
